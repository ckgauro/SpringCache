# üß† In-Memory Caching in Spring

**In-memory caching** stores frequently accessed data directly in the RAM of the application‚Äôs JVM. This helps eliminate expensive computations or slow I/O operations (like database or API calls) by serving data quickly from memory. It's ideal for improving performance in read-heavy, latency-sensitive applications where data consistency is not immediately critical.

---

## üìö Table of Contents

1. [ConcurrentMapCache (Spring Default)](#1Ô∏è‚É£-concurrentmapcache-spring-default)
2. [Caffeine](#2Ô∏è‚É£-caffeine)
3. [EhCache](#3Ô∏è‚É£-ehcache)

## 1Ô∏è‚É£ ConcurrentMapCache (Spring Default)

Spring Boot's default in-memory cache implementation backed by `ConcurrentHashMap`. Best suited for simple, single-instance applications.

### 1. üóÇ In-Memory Caching in Spring Framework

In-Memory Caching stores data directly in the application's memory (RAM). It offers the fastest access times, ideal for frequently accessed, non-volatile data in single-instance applications.

---

### üìå What Is In-Memory Caching?

In-memory caching means storing method results in the application‚Äôs RAM, making future access significantly faster without re-executing the method or querying the database.

**Characteristics:**

- Fastest type of caching.
- Local to a single JVM (not shared across instances).
- Volatile: Cleared on application restart or memory overflow.

---

### üß† Use Cases

- Read-heavy operations.
- Static or rarely changing data (e.g., configurations, lookups).
- Scenarios where horizontal scaling is not required.

---

### üîß Enabling In-Memory Caching in Spring

#### 1. Add Caching Starter (for Spring Boot apps)

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
```

### 2. Enable Caching

Enable caching by annotating your configuration class:

```java
@Configuration
@EnableCaching
public class AppConfig {
}
```

### üì¶ Built-in In-Memory Cache: `ConcurrentMapCache`

By default, Spring uses `ConcurrentMapCache` ‚Äî a thread-safe wrapper around Java‚Äôs `ConcurrentHashMap`.

---

### üìò Example:

```java
@Service
public class BookService {

    @Cacheable("books")
    public Book findBookByIsbn(String isbn) {
        simulateSlowLookup();
        return new Book(isbn, "Some Book");
    }

    private void simulateSlowLookup() {
        try {
            Thread.sleep(2000L);
        } catch (InterruptedException e) {
            throw new IllegalStateException(e);
        }
    }
}

```

> **First call** is slow (simulates 2 seconds).  
> **Subsequent calls** with the same ISBN are instant.

---

### üìÅ Application Configuration

No need to configure `application.yml` for the default in-memory cache. However, you can explicitly declare a `CacheManager` bean:

```java
@Bean
public CacheManager cacheManager() {
    return new ConcurrentMapCacheManager("books");
}
```

### üõ† Managing In-Memory Cache

**Evict cache entries manually:**

```java
@CacheEvict(value = "books", key = "#isbn")
public void evictBookCache(String isbn) { }
```

### Update cache without bypassing method logic:

```java
@CachePut(value = "books", key = "#book.isbn")
public Book updateBook(Book book) {
    return bookRepository.save(book);
}
```

### ‚ö†Ô∏è Limitations

| Limitation     | Explanation                                                         |
| -------------- | ------------------------------------------------------------------- |
| Not Shared     | Each instance has its own cache (not suitable for distributed apps) |
| Memory Bound   | Consumes JVM heap space; can lead to OutOfMemoryError               |
| No Expiry      | Entries persist until evicted or app restarts                       |
| No TTL Support | Requires external tools (e.g., Caffeine) for automatic TTL          |

---

### üöÄ Alternatives for Advanced In-Memory Caching

| Library  | Advantages                                                  |
| -------- | ----------------------------------------------------------- |
| Caffeine | Expiry policies, size-based eviction, excellent performance |
| Ehcache  | Rich configuration, TTL support, optional disk persistence  |

---

# üß© Using ConcurrentMapCache in Spring (In-Memory Cache)

`ConcurrentMapCache` is Spring's default in-memory cache implementation using a thread-safe `ConcurrentHashMap`. It is ideal for simple caching scenarios within a single JVM.

---

## 1Ô∏è‚É£ Setup and Configuration

By default, Spring Boot auto-configures `ConcurrentMapCache` when you enable caching with `@EnableCaching`.

If you want to define it explicitly:

```java
@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public CacheManager cacheManager() {
        // Creates a ConcurrentMapCacheManager with caches named "books" and "authors"
        return new ConcurrentMapCacheManager("books", "authors");
    }
}

```

## 2Ô∏è‚É£ Basic Usage Examples with Caching Annotations

### üì¶ Example Service

```java
@Service
public class BookService {

    private void simulateSlowService() {
        try {
            Thread.sleep(2000L); // Simulate 2-second delay
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    @Cacheable("books")
    public Book getBookByIsbn(String isbn) {
        simulateSlowService(); // Expensive operation
        return new Book(isbn, "Effective Java", "Joshua Bloch");
    }

    @CachePut(value = "books", key = "#book.isbn")
    public Book updateBook(Book book) {
        return book; // Imagine DB update here
    }

    @CacheEvict(value = "books", key = "#isbn")
    public void deleteBookFromCache(String isbn) {
        // Cache eviction for a single book
    }

    @CacheEvict(value = "books", allEntries = true)
    public void clearCache() {
        // Evicts all entries in 'books' cache
    }
}

```

## 3Ô∏è‚É£ What Happens Under the Hood?

| Annotation    | Behavior                                                                                                                |
| ------------- | ----------------------------------------------------------------------------------------------------------------------- |
| `@Cacheable`  | Checks if the key exists in cache. If yes, returns cached value. If no, executes method, caches result, and returns it. |
| `@CachePut`   | Always runs the method and puts its return value in the cache.                                                          |
| `@CacheEvict` | Removes a specific entry or all entries from the cache.                                                                 |

---

## 4Ô∏è‚É£ Testing ConcurrentMapCache Behavior

```java
@SpringBootTest
public class BookServiceTests {

    @Autowired
    BookService bookService;

    @Test
    public void testCacheable() {
        long start = System.currentTimeMillis();
        Book book1 = bookService.getBookByIsbn("123-456");
        long timeFirstCall = System.currentTimeMillis() - start;

        start = System.currentTimeMillis();
        Book book2 = bookService.getBookByIsbn("123-456");
        long timeSecondCall = System.currentTimeMillis() - start;

        assertTrue(timeSecondCall < timeFirstCall); // Indicates cache hit
        assertEquals(book1.getIsbn(), book2.getIsbn());
    }

    @Test
    public void testCacheEvict() {
        bookService.getBookByIsbn("999-999");  // Caches the book
        bookService.deleteBookFromCache("999-999");  // Evicts it

        long start = System.currentTimeMillis();
        bookService.getBookByIsbn("999-999");  // Re-executes expensive method
        long duration = System.currentTimeMillis() - start;

        assertTrue(duration >= 2000L); // Confirms cache was evicted
    }
}
```

## 5Ô∏è‚É£ Advanced: Using Custom Cache Key

### üîπ Custom Key Expression

Use SpEL (Spring Expression Language) to customize cache keys dynamically:

```java
@Cacheable(value = "books", key = "#isbn.toUpperCase()")
public Book getBookByIsbn(String isbn) {
    // This will cache the result with the key as the upper-case version of the ISBN
    ...
}
```

## üî∏ Custom Key Generator

Define a reusable `KeyGenerator` bean when you need advanced key generation logic:

```java
@Bean("customKeyGenerator")
public KeyGenerator keyGenerator() {
    return (target, method, params) -> {
        // Use lowercase version of first parameter as cache key
        return params.length > 0 ? params[0].toString().toLowerCase() : "defaultKey";
    };
}
```

## üî∏ Apply the Custom Key Generator

Use the custom key generator in your service method for precise control over cache keys:

```java
@Cacheable(value = "books", keyGenerator = "customKeyGenerator")
public Book getBookByIsbn(String isbn) {
    // Caches using lowercase version of ISBN as key
    return new Book(isbn, "Effective Java", "Joshua Bloch");
}
```

## 6Ô∏è‚É£ Limitations of ConcurrentMapCache

| Limitation       | Explanation                                                                |
| ---------------- | -------------------------------------------------------------------------- |
| Unbounded Size   | No automatic eviction; memory usage can grow indefinitely                  |
| No TTL           | Lacks time-to-live (TTL) or expiry support                                 |
| Local Cache Only | Cache is limited to the current JVM instance; not shared across JVM nodes  |
| Best Use Case    | Ideal for prototyping or simple, small-scale, single-instance applications |

---

## üìã Summary

| Feature        | Description                                     |
| -------------- | ----------------------------------------------- |
| Implementation | Uses `ConcurrentHashMap` internally             |
| Thread-safe    | ‚úÖ Yes                                          |
| Cache Storage  | In JVM heap (RAM)                               |
| TTL Support    | ‚ùå No built-in expiry mechanism                 |
| Eviction       | Manual (via `@CacheEvict`)                      |
| Shared Cache   | ‚ùå Not shared between JVM/application instances |
| Usage          | Simple, fast, local in-memory caching           |

## 2Ô∏è‚É£ Caffeine

A high-performance, near-optimal caching library for Java with support for features like TTL, eviction policies, and size-based eviction.

## 3Ô∏è‚É£ EhCache

A robust, flexible in-memory and persistent caching solution widely used for enterprise Java applications. Supports clustering and advanced configuration.
