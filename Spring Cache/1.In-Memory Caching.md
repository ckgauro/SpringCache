# üß† In-Memory Caching in Spring

**In-memory caching** stores frequently accessed data directly in the RAM of the application‚Äôs JVM. This helps eliminate expensive computations or slow I/O operations (like database or API calls) by serving data quickly from memory. It's ideal for improving performance in read-heavy, latency-sensitive applications where data consistency is not immediately critical.

---

## üìö Table of Contents

1. [ConcurrentMapCache (Spring Default)](#1Ô∏è‚É£-concurrentmapcache-spring-default)
2. [Caffeine](#2Ô∏è‚É£-caffeine)
3. [EhCache](#3Ô∏è‚É£-ehcache)

## 1Ô∏è‚É£ ConcurrentMapCache (Spring Default)

Spring Boot's default in-memory cache implementation backed by `ConcurrentHashMap`. Best suited for simple, single-instance applications.

### 1. üóÇ In-Memory Caching in Spring Framework

In-Memory Caching stores data directly in the application's memory (RAM). It offers the fastest access times, ideal for frequently accessed, non-volatile data in single-instance applications.

---

### üìå What Is In-Memory Caching?

In-memory caching means storing method results in the application‚Äôs RAM, making future access significantly faster without re-executing the method or querying the database.

**Characteristics:**

- Fastest type of caching.
- Local to a single JVM (not shared across instances).
- Volatile: Cleared on application restart or memory overflow.

---

### üß† Use Cases

- Read-heavy operations.
- Static or rarely changing data (e.g., configurations, lookups).
- Scenarios where horizontal scaling is not required.

---

### üîß Enabling In-Memory Caching in Spring

#### 1. Add Caching Starter (for Spring Boot apps)

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
```

### 2. Enable Caching

Enable caching by annotating your configuration class:

```java
@Configuration
@EnableCaching
public class AppConfig {
}
```

### üì¶ Built-in In-Memory Cache: `ConcurrentMapCache`

By default, Spring uses `ConcurrentMapCache` ‚Äî a thread-safe wrapper around Java‚Äôs `ConcurrentHashMap`.

---

### üìò Example:

```java
@Service
public class BookService {

    @Cacheable("books")
    public Book findBookByIsbn(String isbn) {
        simulateSlowLookup();
        return new Book(isbn, "Some Book");
    }

    private void simulateSlowLookup() {
        try {
            Thread.sleep(2000L);
        } catch (InterruptedException e) {
            throw new IllegalStateException(e);
        }
    }
}

```

> **First call** is slow (simulates 2 seconds).  
> **Subsequent calls** with the same ISBN are instant.

---

### üìÅ Application Configuration

No need to configure `application.yml` for the default in-memory cache. However, you can explicitly declare a `CacheManager` bean:

```java
@Bean
public CacheManager cacheManager() {
    return new ConcurrentMapCacheManager("books");
}
```

### üõ† Managing In-Memory Cache

**Evict cache entries manually:**

```java
@CacheEvict(value = "books", key = "#isbn")
public void evictBookCache(String isbn) { }
```

### Update cache without bypassing method logic:

```java
@CachePut(value = "books", key = "#book.isbn")
public Book updateBook(Book book) {
    return bookRepository.save(book);
}
```

### ‚ö†Ô∏è Limitations

| Limitation     | Explanation                                                         |
| -------------- | ------------------------------------------------------------------- |
| Not Shared     | Each instance has its own cache (not suitable for distributed apps) |
| Memory Bound   | Consumes JVM heap space; can lead to OutOfMemoryError               |
| No Expiry      | Entries persist until evicted or app restarts                       |
| No TTL Support | Requires external tools (e.g., Caffeine) for automatic TTL          |

---

### üöÄ Alternatives for Advanced In-Memory Caching

| Library  | Advantages                                                  |
| -------- | ----------------------------------------------------------- |
| Caffeine | Expiry policies, size-based eviction, excellent performance |
| Ehcache  | Rich configuration, TTL support, optional disk persistence  |

---

# üß© Using ConcurrentMapCache in Spring (In-Memory Cache)

`ConcurrentMapCache` is Spring's default in-memory cache implementation using a thread-safe `ConcurrentHashMap`. It is ideal for simple caching scenarios within a single JVM.

---

## 1Ô∏è‚É£ Setup and Configuration

By default, Spring Boot auto-configures `ConcurrentMapCache` when you enable caching with `@EnableCaching`.

If you want to define it explicitly:

```java
@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public CacheManager cacheManager() {
        // Creates a ConcurrentMapCacheManager with caches named "books" and "authors"
        return new ConcurrentMapCacheManager("books", "authors");
    }
}

```

## 2Ô∏è‚É£ Basic Usage Examples with Caching Annotations

### üì¶ Example Service

```java
@Service
public class BookService {

    private void simulateSlowService() {
        try {
            Thread.sleep(2000L); // Simulate 2-second delay
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    @Cacheable("books")
    public Book getBookByIsbn(String isbn) {
        simulateSlowService(); // Expensive operation
        return new Book(isbn, "Effective Java", "Joshua Bloch");
    }

    @CachePut(value = "books", key = "#book.isbn")
    public Book updateBook(Book book) {
        return book; // Imagine DB update here
    }

    @CacheEvict(value = "books", key = "#isbn")
    public void deleteBookFromCache(String isbn) {
        // Cache eviction for a single book
    }

    @CacheEvict(value = "books", allEntries = true)
    public void clearCache() {
        // Evicts all entries in 'books' cache
    }
}

```

## 3Ô∏è‚É£ What Happens Under the Hood?

| Annotation    | Behavior                                                                                                                |
| ------------- | ----------------------------------------------------------------------------------------------------------------------- |
| `@Cacheable`  | Checks if the key exists in cache. If yes, returns cached value. If no, executes method, caches result, and returns it. |
| `@CachePut`   | Always runs the method and puts its return value in the cache.                                                          |
| `@CacheEvict` | Removes a specific entry or all entries from the cache.                                                                 |

---

## 4Ô∏è‚É£ Testing ConcurrentMapCache Behavior

```java
@SpringBootTest
public class BookServiceTests {

    @Autowired
    BookService bookService;

    @Test
    public void testCacheable() {
        long start = System.currentTimeMillis();
        Book book1 = bookService.getBookByIsbn("123-456");
        long timeFirstCall = System.currentTimeMillis() - start;

        start = System.currentTimeMillis();
        Book book2 = bookService.getBookByIsbn("123-456");
        long timeSecondCall = System.currentTimeMillis() - start;

        assertTrue(timeSecondCall < timeFirstCall); // Indicates cache hit
        assertEquals(book1.getIsbn(), book2.getIsbn());
    }

    @Test
    public void testCacheEvict() {
        bookService.getBookByIsbn("999-999");  // Caches the book
        bookService.deleteBookFromCache("999-999");  // Evicts it

        long start = System.currentTimeMillis();
        bookService.getBookByIsbn("999-999");  // Re-executes expensive method
        long duration = System.currentTimeMillis() - start;

        assertTrue(duration >= 2000L); // Confirms cache was evicted
    }
}
```

## 5Ô∏è‚É£ Advanced: Using Custom Cache Key

### üîπ Custom Key Expression

Use SpEL (Spring Expression Language) to customize cache keys dynamically:

```java
@Cacheable(value = "books", key = "#isbn.toUpperCase()")
public Book getBookByIsbn(String isbn) {
    // This will cache the result with the key as the upper-case version of the ISBN
    ...
}
```

## üî∏ Custom Key Generator

Define a reusable `KeyGenerator` bean when you need advanced key generation logic:

```java
@Bean("customKeyGenerator")
public KeyGenerator keyGenerator() {
    return (target, method, params) -> {
        // Use lowercase version of first parameter as cache key
        return params.length > 0 ? params[0].toString().toLowerCase() : "defaultKey";
    };
}
```

## üî∏ Apply the Custom Key Generator

Use the custom key generator in your service method for precise control over cache keys:

```java
@Cacheable(value = "books", keyGenerator = "customKeyGenerator")
public Book getBookByIsbn(String isbn) {
    // Caches using lowercase version of ISBN as key
    return new Book(isbn, "Effective Java", "Joshua Bloch");
}
```

## 6Ô∏è‚É£ Limitations of ConcurrentMapCache

| Limitation       | Explanation                                                                |
| ---------------- | -------------------------------------------------------------------------- |
| Unbounded Size   | No automatic eviction; memory usage can grow indefinitely                  |
| No TTL           | Lacks time-to-live (TTL) or expiry support                                 |
| Local Cache Only | Cache is limited to the current JVM instance; not shared across JVM nodes  |
| Best Use Case    | Ideal for prototyping or simple, small-scale, single-instance applications |

## üìå What Determines the Maximum Cache Size?

With 8GB RAM allocated to the application, only a portion of that memory is usable by the JVM heap. The actual cache size depends on:

| Factor             | Description                                                             |
| ------------------ | ----------------------------------------------------------------------- |
| JVM Heap Size      | Defined via `-Xmx` JVM option (e.g., `-Xmx6g` means 6GB max heap)       |
| Other Memory Usage | Application logic, threads, GC metadata, etc., consume part of the heap |
| Data Object Size   | Size of cached objects ‚Äî bigger objects = fewer entries                 |
| No Eviction        | Without size or TTL limits, risk of `OutOfMemoryError`                  |

---

## üìç Example

```bash
java -Xms4g -Xmx6g -jar app.jar
```

- You gave the JVM a maximum of **6GB heap**.
- Assume your app (without cache) uses approximately **2GB** on average.
- ‚û°Ô∏è That leaves around **4GB** available for caching.
- üìä If each cached object is approximately **100KB**, you can store about: 4GB / 100KB = ~40,000 entries

before memory pressure begins to build.

---

## üìõ Problem With Unbounded `ConcurrentMapCache`

| üõë Risk            | ‚ö†Ô∏è Impact                                              |
| ------------------ | ------------------------------------------------------ |
| Memory leak        | Heap fills up, eventually causing `OutOfMemoryError`   |
| No TTL             | Stale data may stay in memory indefinitely             |
| No eviction policy | You cannot control memory growth or stale data cleanup |

---

## üìã Summary

| Feature        | Description                                     |
| -------------- | ----------------------------------------------- |
| Implementation | Uses `ConcurrentHashMap` internally             |
| Thread-safe    | ‚úÖ Yes                                          |
| Cache Storage  | In JVM heap (RAM)                               |
| TTL Support    | ‚ùå No built-in expiry mechanism                 |
| Eviction       | Manual (via `@CacheEvict`)                      |
| Shared Cache   | ‚ùå Not shared between JVM/application instances |
| Usage          | Simple, fast, local in-memory caching           |

---

## 2Ô∏è‚É£ Caffeine

## ‚ö° Caffeine Cache in Spring Boot

**Caffeine** is a high-performance, in-memory caching library for Java 8+.  
It provides flexible, efficient caching strategies with support for **automatic eviction policies**, **TTL**, **size limits**, and more.  
It is often used as an **advanced replacement** for Spring‚Äôs default `ConcurrentMapCache`.

---

### üöÄ Why Use Caffeine?

| Feature         | ‚úÖ Caffeine                  | ‚ùå ConcurrentMapCache (Default) |
| --------------- | ---------------------------- | ------------------------------- |
| Eviction Policy | ‚úÖ Size-based, time-based    | ‚ùå None (grows indefinitely)    |
| TTL Support     | ‚úÖ Expire after write/access | ‚ùå Not supported                |
| Performance     | üöÄ Highly optimized          | üê¢ Basic                        |
| Memory-Aware    | ‚úÖ Yes                       | ‚ùå No                           |
| Stats Support   | ‚úÖ Yes                       | ‚ùå No                           |

---

### üß© Key Features

- ‚úÖ Automatic eviction (by size or time)
- ‚úÖ Asynchronous loading
- ‚úÖ Expire after write / access
- ‚úÖ Refresh after write
- ‚úÖ Manual and automatic caching APIs
- ‚úÖ Thread-safe and non-blocking

## ‚ö° Full Example: Caffeine Cache with Spring Boot 3.2 and JDK 21

This guide shows how to integrate and use **Caffeine** ‚Äî a high-performance Java caching library ‚Äî with **Spring Boot 3.2+** and **JDK 21**.

---

### üì¶ 1. Add Dependencies

**`pom.xml`**

```xml
<dependencies>
  <!-- Spring Boot Starter Cache -->
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
  </dependency>

  <!-- Caffeine Cache Library -->
  <dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
  </dependency>
</dependencies>
```

### ‚öôÔ∏è 2. Configure Caching in `application.yml`

```yaml
spring:
  cache:
    type: caffeine
    caffeine:
      spec: maximumSize=1000,expireAfterWrite=10m
```

- **maximumSize=1000:** Caches up to 1,000 items
- **expireAfterWrite=10m:** Each entry expires 10 minutes after creation

### üß† 3. Enable Caching

```java
@Configuration
@EnableCaching
public class CacheConfig {
}
```

### üìö 4. Example Domain: Book

```java
public record Book(String isbn, String title, String author) {}

```

### üõ† 5. Service Layer: BookService

```java
@Service
public class BookService {

    @Cacheable("books")
    public Book getBookByIsbn(String isbn) {
        simulateSlowService();
        return new Book(isbn, "Clean Code", "Robert C. Martin");
    }

    @CachePut(value = "books", key = "#book.isbn")
    public Book updateBook(Book book) {
        return book;
    }

    @CacheEvict(value = "books", key = "#isbn")
    public void removeBookFromCache(String isbn) {
        // Removes one entry
    }

    @CacheEvict(value = "books", allEntries = true)
    public void clearCache() {
        // Removes all entries
    }

    private void simulateSlowService() {
        try {
            Thread.sleep(2000L);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

```

### üß™ 6. REST Controller

```java
@RestController
@RequestMapping("/api/books")
public class BookController {

    private final BookService bookService;

    public BookController(BookService bookService) {
        this.bookService = bookService;
    }

    @GetMapping("/{isbn}")
    public Book getBook(@PathVariable String isbn) {
        return bookService.getBookByIsbn(isbn);
    }

    @PostMapping
    public Book updateBook(@RequestBody Book book) {
        return bookService.updateBook(book);
    }

    @DeleteMapping("/{isbn}")
    public void evictBook(@PathVariable String isbn) {
        bookService.removeBookFromCache(isbn);
    }

    @DeleteMapping
    public void clearAll() {
        bookService.clearCache();
    }
}

```

### ‚úÖ 7. Test the Cache Behavior

```bash
curl http://localhost:8080/api/books/12345  # First call: slow
curl http://localhost:8080/api/books/12345  # Second call: instant
```

### üß∞ Optional: Custom CacheManager (if you want programmatic config)

```java
@Bean
public CacheManager cacheManager() {
Caffeine<Object, Object> caffeineBuilder = Caffeine.newBuilder()
.expireAfterWrite(10, TimeUnit.MINUTES)
.maximumSize(1000);

    CaffeineCacheManager cacheManager = new CaffeineCacheManager("books");
    cacheManager.setCaffeine(caffeineBuilder);
    return cacheManager;

}
```

### üîé 8. Monitor Caffeine Cache

- Use Spring Boot Actuator:

```xml
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

```yml
management:
  endpoints:
    web:
      exposure:
        include: caches, health, metrics
```

Visit:

```bash
GET http://localhost:8080/actuator/caches
GET http://localhost:8080/actuator/metrics/cache.gets
```

## üßæ Summary

| Feature               | Value                             |
| --------------------- | --------------------------------- |
| **Cache Type**        | Caffeine                          |
| **TTL Support**       | ‚úÖ Yes                            |
| **Size Limit**        | ‚úÖ Yes                            |
| **Thread-safe**       | ‚úÖ Yes                            |
| **Application Type**  | Single-instance (not distributed) |
| **Eviction Strategy** | LRU (default)                     |

---

## 3Ô∏è‚É£ EhCache

A robust, flexible in-memory and persistent caching solution widely used for enterprise Java applications. Supports clustering and advanced configuration.
