## 1. 🗂 In-Memory Caching in Spring Framework

In-Memory Caching stores data directly in the application's memory (RAM). It offers the fastest access times, ideal for frequently accessed, non-volatile data in single-instance applications.

---

### 📌 What Is In-Memory Caching?

In-memory caching means storing method results in the application’s RAM, making future access significantly faster without re-executing the method or querying the database.

**Characteristics:**

- Fastest type of caching.
- Local to a single JVM (not shared across instances).
- Volatile: Cleared on application restart or memory overflow.

---

### 🧠 Use Cases

- Read-heavy operations.
- Static or rarely changing data (e.g., configurations, lookups).
- Scenarios where horizontal scaling is not required.

---

### 🔧 Enabling In-Memory Caching in Spring

#### 1. Add Caching Starter (for Spring Boot apps)

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
```

### 2. Enable Caching

Enable caching by annotating your configuration class:

```java
@Configuration
@EnableCaching
public class AppConfig {
}
```

### 📦 Built-in In-Memory Cache: `ConcurrentMapCache`

By default, Spring uses `ConcurrentMapCache` — a thread-safe wrapper around Java’s `ConcurrentHashMap`.

---

### 📘 Example:

```java
@Service
public class BookService {

    @Cacheable("books")
    public Book findBookByIsbn(String isbn) {
        simulateSlowLookup();
        return new Book(isbn, "Some Book");
    }

    private void simulateSlowLookup() {
        try {
            Thread.sleep(2000L);
        } catch (InterruptedException e) {
            throw new IllegalStateException(e);
        }
    }
}

```

> **First call** is slow (simulates 2 seconds).  
> **Subsequent calls** with the same ISBN are instant.

---

### 📁 Application Configuration

No need to configure `application.yml` for the default in-memory cache. However, you can explicitly declare a `CacheManager` bean:

```java
@Bean
public CacheManager cacheManager() {
    return new ConcurrentMapCacheManager("books");
}
```

### 🛠 Managing In-Memory Cache

**Evict cache entries manually:**

```java
@CacheEvict(value = "books", key = "#isbn")
public void evictBookCache(String isbn) { }
```

### Update cache without bypassing method logic:

```java
@CachePut(value = "books", key = "#book.isbn")
public Book updateBook(Book book) {
    return bookRepository.save(book);
}
```

### ⚠️ Limitations

| Limitation     | Explanation                                                         |
| -------------- | ------------------------------------------------------------------- |
| Not Shared     | Each instance has its own cache (not suitable for distributed apps) |
| Memory Bound   | Consumes JVM heap space; can lead to OutOfMemoryError               |
| No Expiry      | Entries persist until evicted or app restarts                       |
| No TTL Support | Requires external tools (e.g., Caffeine) for automatic TTL          |

---

### 🚀 Alternatives for Advanced In-Memory Caching

| Library  | Advantages                                                  |
| -------- | ----------------------------------------------------------- |
| Caffeine | Expiry policies, size-based eviction, excellent performance |
| Ehcache  | Rich configuration, TTL support, optional disk persistence  |

---

### 📦 Example with Caffeine

#### 📄 Maven Dependency

```xml
<dependency>
  <groupId>com.github.ben-manes.caffeine</groupId>
  <artifactId>caffeine</artifactId>
</dependency>
```
